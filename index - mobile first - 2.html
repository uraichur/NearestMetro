<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NammaTrip</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet -->
  <link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Geoapify Address Autocomplete (local UMD) -->
  <script src="./geocoder-autocomplete.min.js"></script>

  <style>
    :root{
      --bg:#0b1020; --panel:#121833; --text:#f4f7ff; --muted:#a8b2d1; --brand:#4da3ff;
      --line-metro:#32d3a7; --line-bus:#ffb02e; --line-auto:#ff5c8a; --line-walk:#9aa4c7;
      --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      display:grid; grid-template-rows:auto 1fr; min-height:100vh;
    }

    /* Top bar */
    header{
      position:sticky; top:0; z-index:1000;
      padding:10px 14px; padding-top:calc(10px + var(--safe-top));
      background:var(--panel); border-bottom:1px solid #1c2c57;
      display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center;
    }
    .inputs{ display:flex; gap:8px; width:100%; align-items:center }
    .input-wrap{ position:relative; flex:1; min-width:260px; display:flex; gap:6px; align-items:center }
    #from, #to{ position:relative; flex:1; min-width:0; display:flex }
    .geoapify-autocomplete{ width:100% }
    .geoapify-autocomplete-input{
      width:100%; font-size:15px; line-height:1.3;
      padding:12px 14px; border-radius:10px; border:1px solid #2a3260;
      background:#0f1430; color:var(--text);
    }
    .mini-btn{
      background:#0e1a46; color:#c9d6ff; border:1px solid #263b86;
      padding:8px 10px; border-radius:8px; cursor:pointer; font-size:12px; white-space:nowrap;
    }
    .btn{
      background:var(--brand); color:#071224; border:0; padding:12px 16px;
      border-radius:10px; cursor:pointer; font-weight:700; white-space:nowrap; min-height:44px;
    }
    /* Suggestions absolute so inputs don't grow */
    .geoapify-autocomplete-items{
      position:absolute; top:calc(100% + 6px); left:0; right:0;
      max-height:min(50vh, 320px); overflow:auto; z-index:9999;
      background:#0e1430; border:1px solid #2a3260; color:var(--text);
      border-radius:12px; -webkit-overflow-scrolling:touch;
    }
    .geoapify-autocomplete-item{ padding:8px 10px }
    .geoapify-autocomplete-item.active, .geoapify-autocomplete-item:hover{ background:#1a2147 }
    .geoapify-close-button{ display:none !important }

    /* Main area: map + right panel (desktop) */
    .main{
      display:grid; grid-template-columns:1fr 420px; grid-template-rows:1fr; gap:12px;
      padding:12px; height:100%;
    }
    #map{ width:100%; height:100%; min-height:260px; border-radius:12px; overflow:hidden }
    .panel{
      background:rgba(7,12,30,.96); border:1px solid #213469; border-radius:14px;
      display:flex; flex-direction:column; min-height:0;
    }
    .panel header{ padding:10px 12px; border-bottom:1px solid #1c2c57 }
    .results{ padding:12px; overflow:auto }
    .step{ margin:6px 0 }
    .muted{ color:var(--muted); font-size:12px }
    .spin-wrap{ display:flex; align-items:center; gap:8px; color:var(--muted); padding:6px 0 }
    .spinner{ width:14px; height:14px; border:2px solid #2a4699; border-top-color:#8fb3ff; border-radius:50%; animation:spin .8s linear infinite }
    @keyframes spin{ to{ transform:rotate(360deg) } }

    /* Mobile: panel becomes bottom sheet */
    @media (max-width: 1023.98px){
      header{ grid-template-columns:1fr; gap:10px }
      .inputs{ flex-direction:column; align-items:stretch }
      .input-wrap{ min-width:unset }
      .main{ grid-template-columns:1fr; grid-template-rows:1fr auto; padding:0 }
      #map{ border-radius:0 }
      .panel{
        border-left:none; border-right:none; border-bottom:none; border-radius:14px 14px 0 0;
        position:sticky; bottom:0; max-height:55vh; backdrop-filter:blur(8px)
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="inputs">
      <div class="input-wrap">
        <div id="from"></div>
        <button id="gpsBtn" class="mini-btn" title="Use GPS again">GPS</button>
        <button id="pickBtn" class="mini-btn" title="Pick on map">Pick</button>
      </div>
      <div id="to" class="input-wrap"></div>
    </div>
    <button id="searchBtn" class="btn">Search</button>
  </header>

  <section class="main">
    <div id="map"></div>
    <aside class="panel" id="panel">
      <header><h3 style="margin:0;font-size:16px">Metro Trip Plan (Bengaluru)</h3></header>
      <div class="results" id="results"><div class="muted">Detecting your location… You can also set <strong>From</strong> via GPS or Pick, then type <strong>To</strong> and hit Search.</div></div>
    </aside>
  </section>

<script>
  // ====== KEYS & PROVIDERS ======
  const API_KEY = "bcf9d8cdc88742ca83abd7ff5735b5a1";  // Geoapify
  const ROUTE_PROVIDER = "GEOAPIFY";
  const HERE_API_KEY = "PASTE_YOUR_HERE_API_KEY_HERE";  // not used now

  // ====== CONFIG ======
  const BLR = { lat: 12.9716, lon: 77.5946, radiusMeters: 42000 };
  const TILE_URL = `https://maps.geoapify.com/v1/tile/dark-matter-brown/{z}/{x}/{y}.png?apiKey=${API_KEY}`;
  const ATTRIB = '© <a href="https://www.openstreetmap.org/copyright" target="_blank">OSM</a>, © <a href="https://www.geoapify.com/" target="_blank">Geoapify</a>';

  // Rule thresholds
  const WALK_MAX = 500;
  const RICK_MAX = 2100;
  const BUS_STOP_RADIUS = 3000;
  const BUS_QUERY_LIMIT = 50;
  const STOP_WALK_MAX = 500;

  // Performance caps
  const CAND_A_MAX = 8;
  const CAND_B_MAX = 8;
  const PAIRS_PER_A = 3;
  const FETCH_TIMEOUT_MS = 9000;

  // Caches
  const busStopCache = new Map();
  const routeCache = new Map();

  // ====== MAP ======
  const map = L.map('map', { zoomControl: true });
  L.tileLayer(TILE_URL, { attribution: ATTRIB, maxZoom: 20 }).addTo(map);
  map.setView([BLR.lat, BLR.lon], 13);
  const layers = { markers: L.layerGroup().addTo(map), lines: L.layerGroup().addTo(map), routes: L.layerGroup().addTo(map) };

  // ====== AUTOCOMPLETE ======
  const { GeocoderAutocomplete } = window.autocomplete;
  function makeAutocomplete(el){
    return new GeocoderAutocomplete(el, API_KEY, {
      placeholder: "Bengaluru place or address",
      lang: "en",
      filter: { countrycode: ["in"], circle: BLR },
      bias: { proximity: BLR }
    });
  }
  const fromCtl = makeAutocomplete(document.getElementById("from"));
  const toCtl   = makeAutocomplete(document.getElementById("to"));

  let fromPoint=null, toPoint=null, fromLabel="", toLabel="";
  fromCtl.on("select",(f)=>{ if(!f?.properties) return;
    fromPoint = { lat:f.properties.lat, lon:f.properties.lon };
    fromLabel = f.properties.name || f.properties.address_line1 || f.properties.formatted || "Origin";
  });
  toCtl.on("select",(f)=>{ if(!f?.properties) return;
    toPoint = { lat:f.properties.lat, lon:f.properties.lon };
    toLabel = f.properties.name || f.properties.address_line1 || f.properties.formatted || "Destination";
  });

  // ====== “GPS again” & “Pick on map” ======
  document.getElementById("gpsBtn").onclick = () => requestHighAccuracy();
  let pickMode = false, pickMarker=null;
  document.getElementById("pickBtn").onclick = () => {
    pickMode = !pickMode;
    document.getElementById("pickBtn").textContent = pickMode ? "Picking…" : "Pick";
  };
  map.on("click", async (e)=>{
    if (!pickMode) return;
    const { lat, lng } = e.latlng;
    fromPoint = { lat, lon: lng };
    fromLabel = "Picked location";
    if (pickMarker) layers.markers.removeLayer(pickMarker);
    pickMarker = L.marker([lat,lng]).addTo(layers.markers).bindPopup("<strong>From set here</strong>").openPopup();
    // reverse geocode to prettify label & input
    try{
      const revUrl = `https://api.geoapify.com/v1/geocode/reverse?lat=${lat}&lon=${lng}&apiKey=${API_KEY}`;
      const r = await fetchWithTimeout(revUrl); const j = await r.json();
      const p = j?.features?.[0]?.properties;
      const nice = p?.name || p?.address_line1 || p?.formatted;
      if (nice){ fromLabel = nice; try{ fromCtl.setValue(nice); }catch(_){} }
    }catch(_){}
    pickMode = false;
    document.getElementById("pickBtn").textContent = "Pick";
  });

  // ====== Initial geolocation (with stronger options) ======
  (async function initFrom(){
    try{
      await requestHighAccuracy(true);
    }catch(_){
      // Soft fallback to CBD so we never end up undefined
      fromPoint = { lat: 12.9719, lon: 77.5937 };
      fromLabel = "Bengaluru (set origin)";
      try{ if (typeof fromCtl.setValue === "function") fromCtl.setValue(fromLabel); }catch(_){}
      L.marker([fromPoint.lat, fromPoint.lon]).addTo(layers.markers).bindPopup(`<strong>${escapeHtml(fromLabel)}</strong>`);
      map.setView([fromPoint.lat, fromPoint.lon], 13);
      document.getElementById("results").innerHTML =
        `<div class="muted">Couldn't get precise GPS. Tip: enable Wi-Fi/Bluetooth scanning & precise location. Or click <strong>Pick</strong> and choose your exact spot on the map.</div>`;
    }
  })();

  async function requestHighAccuracy(isInit=false){
    const opts = { enableHighAccuracy:true, timeout:15000, maximumAge:0 };
    const pos = await new Promise((res, rej)=>navigator.geolocation.getCurrentPosition(res, rej, opts));
    const { latitude, longitude, accuracy } = pos.coords || {};
    if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) throw new Error("No coords");
    fromPoint = { lat: latitude, lon: longitude };
    let nice = "Current location";
    try{
      const revUrl = `https://api.geoapify.com/v1/geocode/reverse?lat=${latitude}&lon=${longitude}&apiKey=${API_KEY}`;
      const r = await fetchWithTimeout(revUrl); const j = await r.json();
      const p = j?.features?.[0]?.properties;
      nice = p?.name || p?.address_line1 || p?.formatted || "Current location";
    }catch(_){}
    fromLabel = nice + (Number.isFinite(accuracy) ? ` (±${Math.round(accuracy)} m)` : "");
    try{ if (typeof fromCtl.setValue === "function") fromCtl.setValue(fromLabel); }catch(_){}
    L.marker([fromPoint.lat, fromPoint.lon]).addTo(layers.markers).bindPopup(`<strong>${escapeHtml(fromLabel)}</strong><br>Origin (GPS)`);
    if (!isInit) map.setView([fromPoint.lat, fromPoint.lon], 15);
    document.getElementById("results").innerHTML =
      `<div class="muted">From updated via GPS. You can also <strong>Pick</strong> on the map for pinpoint accuracy.</div>`;
  }

  // ====== Search click ======
  document.getElementById("searchBtn").onclick = async () => {
    const r = document.getElementById("results");
    if (!validPt(fromPoint) || !validPt(toPoint)){
      r.innerHTML = "<div class='muted'>Please pick both <strong>From</strong> and <strong>To</strong> from suggestions.</div>";
      return;
    }
    r.innerHTML = `<div class="spin-wrap"><span class="spinner"></span> Processing…</div>`;
    try{
      await buildMetroOnly(fromPoint, toPoint, fromLabel || "Origin", toLabel || "Destination");
    }catch(e){
      console.error(e);
      r.innerHTML = `<div class="muted">Sorry, something went wrong while fetching options. Please try again.</div>`;
    }
  };

  // ====== Metro data ======
  let METRO_CACHE = null; // [{name, lat, lon}]
  async function loadAllMetroOnce(){
    if (METRO_CACHE) return METRO_CACHE;
    const url = `https://api.geoapify.com/v2/places?categories=public_transport.subway` +
                `&filter=countrycode:in|circle:${BLR.lon},${BLR.lat},${BLR.radiusMeters}` +
                `&limit=500&apiKey=${API_KEY}`;
    try{
      const r = await fetchWithTimeout(url);
      if (!r.ok) throw new Error("Metro fetch failed: " + r.status);
      const j = await r.json();
      METRO_CACHE = (j.features||[]).map(f=>{
        const p=f.properties||{};
        const nm=(p.name||p.address_line1||p.formatted||"Metro station").trim();
        return { name:nm, lat:p.lat, lon:p.lon };
      }).filter(validPt);
    }catch(e){
      console.warn("Metro fetch failed", e);
      METRO_CACHE = [];
    }
    return METRO_CACHE;
  }
  function nearestFromList(p, list){
    if (!list?.length) return null;
    return [...list].sort((a,b)=>haversine(p,a)-haversine(p,b))[0];
  }

  // ====== Main builder (metro-centric) ======
  async function buildMetroOnly(from, to, fromName, toName){
    clearMap();
    if (!validPt(from) || !validPt(to)){
      document.getElementById("results").innerHTML = "<div class='muted'>Invalid coordinates. Please re-select both places.</div>";
      return;
    }
    L.marker([from.lat, from.lon]).addTo(layers.markers).bindPopup(`<strong>${escapeHtml(fromName)}</strong><br>Origin`);
    L.marker([to.lat, to.lon]).addTo(layers.markers).bindPopup(`<strong>${escapeHtml(toName)}</strong><br>Destination`);

    const allMetro = await loadAllMetroOnce();
    const fromM = nearestFromList(from, allMetro);
    const toM   = nearestFromList(to,   allMetro);
    if (!fromM || !toM){
      document.getElementById("results").innerHTML = "<div class='muted'>No suitable metro route found.</div>";
      return;
    }

    const first = await connectorSmart(from, fromM, "to",   {srcLabel: fromName, dstLabel: fromM.name});
    const last  = await connectorSmart(toM,  to,   "from", {srcLabel: toM.name,  dstLabel: toName});

    drawPolyline([[fromM.lat, fromM.lon],[toM.lat, toM.lon]], getCss('--line-metro'), 5, null);

    const totalProxy = first.dist + haversine(fromM,toM) + last.dist;
    const steps = [
      first.html,
      stepMetro(`Take Namma Metro from ${escapeHtml(fromM.name)} → ${escapeHtml(toM.name)}.`),
      last.html
    ];
    document.getElementById("results").innerHTML = `
      <div><strong>Metro Route • ${prettyDist(totalProxy)}</strong></div>
      ${steps.join("")}
    `;
    fitAll();
  }

  // ====== Smart connector ======
  async function connectorSmart(a, b, direction, labels){
    const safeTo   = (labels?.dstLabel)  || (direction==="to" ? "destination" : "origin");
    const safeFrom = (labels?.srcLabel)  || (direction==="to" ? "origin" : "destination");

    // Walk
    const rWalk = await routePath(a, b, "walk");
    if (rWalk.dist <= WALK_MAX){
      drawRouteCoords(rWalk.coords, getCss('--line-walk'), 3, '2 4');
      const text = direction==="from"
        ? `Walk from ${escapeHtml(safeFrom)} to ${escapeHtml(safeTo)} (${prettyDist(rWalk.dist)})`
        : `Walk to ${escapeHtml(safeTo)} (${prettyDist(rWalk.dist)})`;
      return { mode:"walk", dist:rWalk.dist, html: stepWalk(text) };
    }

    // Rickshaw
    const rAuto = await routePath(a, b, "drive");
    if (rAuto.dist <= RICK_MAX){
      drawRouteCoords(rAuto.coords, getCss('--line-auto'), 4, '2 6');
      const text = direction==="from"
        ? `From ${escapeHtml(safeFrom)}, take a rickshaw to ${escapeHtml(safeTo)} (${prettyDist(rAuto.dist)})`
        : `Take a rickshaw to ${escapeHtml(safeTo)} (${prettyDist(rAuto.dist)})`;
      return { mode:"auto", dist:rAuto.dist, html: stepAuto(text) };
    }

    // Bus (fast, guarded)
    const bestBus = await findBestBusConnectorFAST(a, b, direction, safeFrom, safeTo);
    if (bestBus){
      if (bestBus.pre.draw) bestBus.pre.draw();
      drawPolyline([[bestBus.stopA.lat,bestBus.stopA.lon],[bestBus.stopB.lat,bestBus.stopB.lon]], getCss('--line-bus'), 5, '6 6');
      if (bestBus.post.draw) bestBus.post.draw();

      const html = [bestBus.pre.html,
        stepBus(`Take a BMTC bus from ${escapeHtml(bestBus.stopA.name)} → ${escapeHtml(bestBus.stopB.name)} (${prettyDist(bestBus.busProxy)}).`),
        bestBus.post.html
      ].join("");
      return { mode:"bus", dist: bestBus.total, html };
    }

    // Fallback rick
    drawRouteCoords(rAuto.coords, getCss('--line-auto'), 4, '2 6');
    const text = direction==="from"
      ? `From ${escapeHtml(safeFrom)}, take a rickshaw to ${escapeHtml(safeTo)} (${prettyDist(rAuto.dist)})`
      : `Take a rickshaw to ${escapeHtml(safeTo)} (${prettyDist(rAuto.dist)})`;
    return { mode:"auto", dist:rAuto.dist, html: stepAuto(text) };
  }

  // ====== FAST bus pairing ======
  async function findBestBusConnectorFAST(a, b, direction, safeFrom, safeTo){
    const stopsA = await findBusStopsCached(a, BUS_STOP_RADIUS, BUS_QUERY_LIMIT);
    const stopsB = await findBusStopsCached(b, BUS_STOP_RADIUS, BUS_QUERY_LIMIT);
    if (!stopsA.length || !stopsB.length) return null;

    const candA = rankNearest(a, stopsA, CAND_A_MAX);
    const candB = rankNearest(b, stopsB, CAND_B_MAX);

    // Stage 1: coarse estimate (no network)
    let bestEst = null;
    for (const stopA of candA){
      const nearestBs = [...candB].sort((s1,s2)=>haversine(stopA,s1)-haversine(stopA,s2)).slice(0, PAIRS_PER_A);
      for (const stopB of nearestBs){
        const total   = haversine(a, stopA) + haversine(stopA, stopB) + haversine(stopB, b);
        if (!bestEst || total < bestEst.total){
          bestEst = { stopA, stopB, total };
        }
      }
    }
    if (!bestEst) return null;

    // Stage 2: confirm only the best pair with real routing and thresholds
    const pre  = await approachLeg(bestEst.stopA, a, "toStop");
    const post = await approachLeg(bestEst.stopB, b, "fromStop");
    const busProxy = haversine(bestEst.stopA, bestEst.stopB);
    return { stopA: bestEst.stopA, stopB: bestEst.stopB, pre, post, busProxy, total: pre.dist + busProxy + post.dist };
  }

  async function approachLeg(stop, end, kind){
    // Walk first
    const w = await routePath(kind==="toStop" ? end : stop, kind==="toStop" ? stop : end, "walk");
    if (w.dist <= STOP_WALK_MAX){
      const html = (kind==="toStop")
        ? stepWalk(`Walk to bus stop ${escapeHtml(stop.name)} (${prettyDist(w.dist)})`)
        : stepWalk(`Walk from ${escapeHtml(stop.name)} to ${escapeHtml(end.name||"destination")} (${prettyDist(w.dist)})`);
      return { dist:w.dist, html, draw:()=>drawRouteCoords(w.coords, getCss('--line-walk'), 3, '2 4') };
    }
    // Else rick
    const d = await routePath(kind==="toStop" ? end : stop, kind==="toStop" ? stop : end, "drive");
    const html = (kind==="toStop")
      ? stepAuto(`Take a rickshaw to bus stop ${escapeHtml(stop.name)} (${prettyDist(d.dist)})`)
      : stepAuto(`From ${escapeHtml(stop.name)}, take a rickshaw to ${escapeHtml(end.name||"destination")} (${prettyDist(d.dist)})`);
    return { dist:d.dist, html, draw:()=>drawRouteCoords(d.coords, getCss('--line-auto'), 4, '2 6') };
  }

  // ====== Bus stops (Geoapify → Overpass fallback) ======
  async function findBusStopsCached(p, radius, limit){
    const key = `${p.lon.toFixed(3)},${p.lat.toFixed(3)},${radius}`;
    if (busStopCache.has(key)) return busStopCache.get(key);

    // Try Geoapify first (some categories may 400 in certain regions)
    const catsToTry = [
      "transport.bus_stop",
      "transport.bus_station",
      "public_transport",
      "public_transport.station"
    ];

    let out = [];
    for (const cats of catsToTry){
      const url = `https://api.geoapify.com/v2/places` +
        `?categories=${encodeURIComponent(cats)}` +
        `&filter=circle:${p.lon},${p.lat},${radius}` +
        `&bias=proximity:${p.lon},${p.lat}` +
        `&limit=${limit}` +
        `&apiKey=${API_KEY}`;
      try{
        const r = await fetchWithTimeout(url);
        if (!r.ok) { console.warn("Geoapify places error", r.status, cats); continue; }
        const j = await r.json();
        out = (j.features||[]).map(f=>{
          const name = (f.properties?.name || f.properties?.address_line1 || f.properties?.formatted || "Bus stop").trim();
          return { name, lat:f.properties.lat, lon:f.properties.lon };
        }).filter(validPt);
        if (out.length) break;
      }catch(e){
        console.warn("Bus stops fetch error for", cats, e);
      }
    }

    // If Geoapify failed/empty, FALL BACK to Overpass (OSM)
    if (!out.length){
      try{
        out = await findBusStopsOverpass(p, radius, limit);
      }catch(e){
        console.warn("Overpass bus-stop fallback failed", e);
      }
    }

    busStopCache.set(key, out);
    return out;
  }

  // Overpass fallback for bus stops (highway=bus_stop or public_transport=platform)
  async function findBusStopsOverpass(p, radius, limit){
    const body = `[out:json][timeout:25];
      (
        node(around:${radius},${p.lat},${p.lon})["highway"="bus_stop"];
        node(around:${radius},${p.lat},${p.lon})["public_transport"="platform"]["bus"="yes"];
      );
      out ${Math.max(10, Math.min(200, limit))};`;
    const r = await fetchWithTimeout("https://overpass-api.nextzen.org/api/interpreter", { // primary mirror (reliable)
      method:"POST",
      headers:{ "Content-Type":"application/x-www-form-urlencoded" },
      body: "data=" + encodeURIComponent(body)
    });
    if (!r.ok){
      // Try classic Overpass as backup
      const r2 = await fetchWithTimeout("https://overpass-api.de/api/interpreter", {
        method:"POST",
        headers:{ "Content-Type":"application/x-www-form-urlencoded" },
        body: "data=" + encodeURIComponent(body)
      });
      if (!r2.ok) throw new Error("Overpass failed");
      const j2 = await r2.json();
      return mapOverpassStops(j2);
    }
    const j = await r.json();
    return mapOverpassStops(j);
  }
  function mapOverpassStops(json){
    const els = json?.elements || [];
    return els.map(n=>{
      const name = n.tags?.name || n.tags?.ref || "Bus stop";
      return { name, lat:n.lat, lon:n.lon };
    }).filter(validPt);
  }

  // ====== Routing (with caching + timeouts) ======
  async function routePath(a, b, mode){
    const key = `${mode}|${a.lat.toFixed(6)},${a.lon.toFixed(6)}|${b.lat.toFixed(6)},${b.lon.toFixed(6)}`;
    if (routeCache.has(key)) return routeCache.get(key);
    const p = (ROUTE_PROVIDER === "HERE") ? routePathHere(a,b,mode) : routePathGeoapify(a,b,mode);
    const res = await p;
    routeCache.set(key, res);
    return res;
  }

  async function routePathHere(a, b, mode){
    const transportMode = (mode === "walk") ? "pedestrian" : "car";
    const url = `https://router.hereapi.com/v8/routes?transportMode=${transportMode}&origin=${a.lat},${a.lon}&destination=${b.lat},${b.lon}&return=summary&units=metric&apikey=${HERE_API_KEY}`;
    try{
      const r = await fetchWithTimeout(url);
      if (!r.ok) throw new Error("HERE routing failed");
      const j = await r.json();
      const section = j?.routes?.[0]?.sections?.[0];
      const dist = Number(section?.summary?.length);
      if (!Number.isFinite(dist) || dist <= 0) throw new Error("No distance");
      return { dist, coords: [[a.lat,a.lon],[b.lat,b.lon]] };
    }catch(e){
      console.warn("HERE routing error; fallback to haversine", e);
      return { dist: Math.max(1, Math.round(haversine(a,b))), coords: [[a.lat,a.lon],[b.lat,b.lon]] };
    }
  }

  async function routePathGeoapify(a, b, mode){
    const url = `https://api.geoapify.com/v1/routing?waypoints=${a.lon},${a.lat}|${b.lon},${b.lat}&mode=${mode}&apiKey=${API_KEY}`;
    try{
      const r = await fetchWithTimeout(url);
      if (!r.ok) throw new Error("routing failed " + r.status);
      const j = await r.json();
      const f = j?.features?.[0];
      let dist = f?.properties?.distance;
      if (!Number.isFinite(dist)){
        const legs = f?.properties?.legs || [];
        dist = legs.reduce((s,lg)=>s + (Number(lg?.distance)||0), 0);
      }
      let coords = [];
      const g = f?.geometry;
      if (g?.type === 'LineString' && Array.isArray(g.coordinates)){
        coords = g.coordinates.map(([lon,lat]) => [lat,lon]);
      } else if (g?.type === 'MultiLineString'){
        coords = g.coordinates.flat().map(([lon,lat]) => [lat,lon]);
      }
      if (!Number.isFinite(dist) || dist <= 0) dist = Math.max(1, Math.round(haversine(a,b)));
      if (!coords.length) coords = [[a.lat,a.lon],[b.lat,b.lon]];
      return { dist, coords };
    }catch(e){
      console.warn("Geoapify routing error; fallback to haversine", e);
      return { dist: Math.max(1, Math.round(haversine(a,b))), coords: [[a.lat,a.lon],[b.lat,b.lon]] };
    }
  }

  // ====== Helpers ======
  function validPt(p){ return p && Number.isFinite(p.lat) && Number.isFinite(p.lon); }

  async function fetchWithTimeout(url, opts={}){
    const ctrl = new AbortController();
    const to = setTimeout(()=>ctrl.abort(), FETCH_TIMEOUT_MS);
    try{
      return await fetch(url, { ...opts, signal: ctrl.signal });
    } finally {
      clearTimeout(to);
    }
  }

  function rankNearest(p, list, n){
    return [...list].sort((a,b)=>haversine(p,a)-haversine(p,b)).slice(0, n);
  }

  function drawRouteCoords(coords, color, weight=4, dashArray=null){
    const opts = { color, weight, opacity:.95 };
    if (dashArray) opts.dashArray = dashArray;
    L.polyline(coords, opts).addTo(layers.routes);
  }
  function drawPolyline(latlngs, color, weight=4, dash=null){
    const opts = { color, weight, opacity:.95 };
    if (dash) opts.dashArray = dash;
    L.polyline(latlngs, opts).addTo(layers.lines);
  }
  function clearMap(){ layers.routes.clearLayers(); layers.lines.clearLayers(); layers.markers.clearLayers(); }
  function fitAll(){
    const bounds = [];
    layers.routes.eachLayer(l => l.getLatLngs().forEach(p=>bounds.push(p)));
    layers.lines.eachLayer(l => l.getLatLngs().forEach(p=>bounds.push(p)));
    layers.markers.eachLayer(l => bounds.push(l.getLatLng()));
    if (bounds.length) map.fitBounds(L.latLngBounds(bounds).pad(0.2));
  }

  function stepMetro(t){ return `<div class="step"><strong>Metro:</strong> ${escapeHtml(t)}</div>`; }
  function stepBus(t){   return `<div class="step"><strong>Bus:</strong> ${escapeHtml(t)}</div>`; }
  function stepAuto(t){  return `<div class="step"><strong>Rickshaw:</strong> ${escapeHtml(t)}</div>`; }
  function stepWalk(t){  return `<div class="step"><strong>Walk:</strong> ${escapeHtml(t)}</div>`; }

  function escapeHtml(s){ return String(s||"").replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim()||'#fff'; }
  function haversine(a,b){
    const toRad = x=>x*Math.PI/180, R=6371000;
    const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
    const s1=toRad(a.lat), s2=toRad(b.lat);
    const h=Math.sin(dLat/2)**2 + Math.cos(s1)*Math.cos(s2)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(h));
  }
  function prettyDist(m){ return m<1000 ? `${Math.round(m)} m` : `${(m/1000).toFixed(1)} km`; }
</script>
</body>
</html>

